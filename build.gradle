import java.nio.file.Files
import java.util.jar.JarEntry
import java.util.jar.JarFile

plugins() {
	id('fabric-loom') version('1.11-SNAPSHOT')
}

version = project.mod_version
group = project.maven_group

base() {
	archivesName = project.archives_base_name
}

sourceSets() {
	main() {
		java() {
			srcDirs = [ file("src/common/java"), file("src/${project.minecraft_version}/java") ]
		}
		resources() {
			srcDirs = [ file("src/common/resources"), file("src/${project.minecraft_version}/resources") ]
		}
	}
	test() {
		java() {
			srcDirs = [ file("src/test/java") ]
		}
		resources() {
			srcDirs = [ file("src/test/resources") ]
		}
	}
}

repositories() {
	maven() {
		url('https://api.modrinth.com/maven')
	}
	//loom does this automatically, but does it too late.
	//we need to ensure this gets added as a repository before
	//all the hacks below that make JIJ dependencies work.
	maven() {
		name = 'MavenCentralLWJGL' //loom checks for this name, so it cannot be changed.
		url(ArtifactRepositoryContainer.MAVEN_CENTRAL_URL)
		content() {
			includeGroup('org.lwjgl')
		}
	}
}

configurations() {
	jijModImplementation() {
		canBeResolved = true
	}
	jijModRuntimeOnly() {
		canBeResolved = true
	}
	jijModCompileOnly() {
		canBeResolved = true
	}
}

static void extractNestedJars(File dependenciesFolder, File toUnpack) {
	try (JarFile jar = new JarFile(toUnpack)) {
		Enumeration<JarEntry> entries = jar.entries()
		while (entries.hasMoreElements()) {
			JarEntry entry = entries.nextElement()
			String name = entry.getName()
			if (name.startsWith('META-INF/jars/') && name.endsWith('.jar')) {
				name = name.substring('META-INF/jars'.length())
				File unpacked = new File(dependenciesFolder, name)
				if (unpacked.exists()) continue
				try (FileOutputStream out = new FileOutputStream(unpacked)) {
					jar.getInputStream(entry).transferTo(out)
				}
				extractNestedJars(dependenciesFolder, unpacked)
			}
		}
	}
}

dependencies() {
	minecraft("com.mojang:minecraft:${ project.minecraft_version }")
	mappings("net.fabricmc:yarn:${ project.yarn_mappings }:v2")
	modImplementation("net.fabricmc:fabric-loader:${ project.loader_version }")
	//modImplementation("net.fabricmc.fabric-api:fabric-api:${ project.fabric_version }")

	jijModImplementation("maven.modrinth:modmenu:${ project.modmenu_version }")
	jijModImplementation("maven.modrinth:cloth-config:${ project.cloth_config_version }")

	annotationProcessor('systems.manifold:manifold-preprocessor:2025.1.27')

	File dependenciesFolder = file('dependencies')
	dependenciesFolder.deleteDir()
	dependenciesFolder.mkdir()
	for (String dependencyType : [ 'implementation', 'runtimeOnly', 'compileOnly' ]) {
		File specificDependenciesFolder = new File(dependenciesFolder, dependencyType)
		specificDependenciesFolder.mkdir()
		for (File from : getConfigurations().getByName("jijMod${ dependencyType.capitalize() }").getResolvedConfiguration().getResolvedArtifacts().file) {
			String fileName = from.getName()
			File to = new File(specificDependenciesFolder, fileName)
			if (!to.exists()) {
				Files.copy(from.toPath(), to.toPath())
				extractNestedJars(specificDependenciesFolder, to)
			}
		}
	}
	modImplementation(fileTree(file('dependencies/implementation')))
	modCompileOnly(fileTree(file('dependencies/compileOnly')))
	modRuntimeOnly(fileTree(file('dependencies/runtimeOnly')))
}

loom() {
	accessWidenerPath = file("src/${ project.minecraft_version }/resources/fractallightning.accesswidener")
}

static int compareVersions(String versionA, String versionB) {
	String[] splitA = versionA.split('\\.')
	String[] splitB = versionB.split('\\.')
	for (int index = 0; index < 3; index++) {
		int compare = Integer.compare(
			Integer.parseInt(splitA[index]),
			Integer.parseInt(splitB[index])
		)
		if (compare != 0) return compare
	}
	return 0
}

int targetJavaVersion = compareVersions(project.minecraft_version, '1.20.5') >= 0 ? 21 : 17
tasks.withType(JavaCompile).configureEach() {
	it.options.encoding = "UTF-8"
}

compileJava() {
	options.compilerArgs.add('-Xplugin:Manifold')
}

java() {
	def javaVersion = JavaVersion.toVersion(targetJavaVersion)
	if (JavaVersion.current() < javaVersion) {
		toolchain.languageVersion = JavaLanguageVersion.of(targetJavaVersion)
	}
	archivesBaseName = project.archives_base_name
	withSourcesJar()

	sourceCompatibility = JavaLanguageVersion.of(17)
	targetCompatibility = JavaLanguageVersion.of(targetJavaVersion)
}

jar() {
	from("LICENSE") {
		rename() { "${ it }_${ project.archivesBaseName }" }
	}
}

tasks.register('copyToReleases', Copy) {
	dependsOn(remapJar)
	from("$projectDir/build/libs") {
		include("$archivesBaseName-${ project.version }.jar")
		rename() {
			"$archivesBaseName-$project.version-MC${ minecraft_version }.jar"
		}
	}
	into(file("releases/${ project.version.toString().replace('.' as char, '/' as char) }"))
}

test() {
	doFirst() {
		if (file("releases/${project.version.toString().replace('.' as char, '/' as char)}/$archivesBaseName-$project.version-MC${minecraft_version}.jar").exists()) {
			throw new IllegalStateException("Release file $project.version-MC$minecraft_version already exists. If you intend to overwrite this file, delete it first. Otherwise, you probably forgot to bump the version.")
		}
	}
}

build() {
	dependsOn(copyToReleases)
}

class Version {

	int major
	int minor

	Version(int major, int minor) {
		this.major = major
		this.minor = minor
	}

	static String pad(int number) {
		return number < 10 ? "0$number" : number.toString()
	}

	String shorthand() {
		return "1${pad(major)}${pad(minor)}"
	}

	String longhand() {
		return "1.${major}.${minor}"
	}
}

Collection<Map.Entry<String, String>> loadProperties(String fileName) {
	Properties properties = new Properties()
	try (InputStream stream = new FileInputStream(file(fileName))) {
		properties.load(stream)
	}
	return properties.entrySet()
}

Map<String, String> loadVersion(Version version) {
	return (
		new HashMap<String, String>()
		.putAll(loadProperties('gradle_common.properties'))
		.putAll(loadProperties("gradle_${version.longhand()}.properties"))
	)
}

tasks.register("Currently V$project.version for MC $project.minecraft_version") {
	group('versions')
	doFirst() {
		println("Currently V$project.version for MC $project.minecraft_version")
	}
}

for (Version version in [
	new Version(20, 1),
	new Version(20, 2),
	new Version(20, 4),
	new Version(20, 6),
	new Version(21, 1),
	new Version(21, 3),
	new Version(21, 4),
	new Version(21, 5),
	new Version(21, 8),
	new Version(21, 9),
]) {
	Version capturedVersion = version
	tasks.register("Switch to ${capturedVersion.longhand()}", WriteProperties) {
		group('versions')
		destinationFile = file('gradle.properties')
		comment('This file was automatically generated by gradle. Do not touch!')
		properties(loadVersion(capturedVersion))
		doLast() {
			file('build.properties').text = (
			"""#This file was automatically generated by gradle. Do not touch!
MC_1_20_0=12000
MC_1_20_1=12001
MC_1_20_2=12002
MC_1_20_3=12003
MC_1_20_4=12004
MC_1_20_5=12005
MC_1_20_6=12006
MC_1_21_0=12100
MC_1_21_1=12101
MC_1_21_2=12102
MC_1_21_3=12103
MC_1_21_4=12104
MC_1_21_5=12105
MC_1_21_6=12106
MC_1_21_7=12107
MC_1_21_8=12108
MC_1_21_9=12109
MC_VERSION=${capturedVersion.shorthand()}"""
			)
		}
	}
}